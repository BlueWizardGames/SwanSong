//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;


namespace weaponsSystem
{
	public static class WCore{
		public delegate void FirePattern(UnityEngine.Transform fireFrom, GameObject shot);
		public delegate float Cooldown(float lastFired);
		public delegate float Actuation(Cooldown lambda_CD, float lastFired); //weapon intensity
		
		public static FirePattern defaultFire()
		{
			return delegate(UnityEngine.Transform fireFrom, GameObject shot) {
				UnityEngine.Object.Instantiate (shot, fireFrom.position, fireFrom.rotation);
			};
		}
		public static FirePattern triFire(float separation)
		{
			FirePattern comboMeal = (angleFire (separation) + angleFire (0) + angleFire (-separation));
			return comboMeal;
		}
		public static FirePattern angleFire(float rotationOffset)
		{
			return delegate(UnityEngine.Transform fireFrom, GameObject shot) {
				Quaternion mu = Quaternion.AngleAxis(rotationOffset + fireFrom.eulerAngles.y 
				                                     , fireFrom.transform.up);
				UnityEngine.Object.Instantiate (shot, fireFrom.position, mu);
			};
		}
		
		public static Cooldown defaultCooldown(float _regularCD)
		{
			return delegate(float lastFired) {
				return (Time.time - lastFired) / _regularCD; 
			};
		}
		
		public static Actuation defaultActuation()
		{
			return delegate(Cooldown cooldownPart, float lastFired) {
				return cooldownPart(lastFired);
			};
		}
		
		public static Actuation smoothedActuation(float _minimumInputDuration,
		                                          float _maximumGap,
		                                          float _maxWindow)
		{
			smoothedActuationImpl v = new smoothedActuationImpl ( _minimumInputDuration,
			                                                _maximumGap,
			                                                _maxWindow);
			return new Actuation (v.Actuate);
		}
		
		private class smoothedActuationImpl{
			private float lastTime = 0;
			private float soFar = 0;
			System.Collections.Generic.Queue<Vector2> timeFrames = new Queue<Vector2>();
			private float minimumInputDuration; //required input duration to trigger
			private float maximumGap; //gap between inputs
			private float maxWindow; // total window for hitting minimumInputDuration
			public smoothedActuationImpl(float _minimumInputDuration,
			                             float _maximumGap,
			                             float _maxWindow)
			{
				lastTime = Time.time;
				minimumInputDuration = _minimumInputDuration;
				maximumGap = _maximumGap;
				maxWindow = _maxWindow;
			}
			
			public float Actuate(Cooldown cooldownPart, float lastFired)
			{
				float delta = Time.deltaTime;
				float tI = Time.time;
				if (timeFrames.Count == 0) { // handles empties and start condition
					timeFrames.Enqueue (new Vector2 (tI, delta));
					soFar = delta;
					lastTime = tI;
				} else if (tI - maximumGap > lastTime) { //checks the gap
					timeFrames.Clear ();
					timeFrames.Enqueue (new Vector2 (tI, delta));
					soFar = delta;
					lastTime = tI;
				} else { // adds new frame, updates soFar, ages out frames, and updates soFar
					soFar += delta;
					lastTime = tI;
					timeFrames.Enqueue(new Vector2(tI, delta));

					while(timeFrames.Peek().x < (lastTime - maxWindow))
					{
						Vector2 s = timeFrames.Dequeue();
						soFar -= s.y;
					}
				}
				//triggers cooldown if soFar is enough to have crossed the input duration threshold.
				if (soFar >= minimumInputDuration)
					return cooldownPart (lastFired);
				return 0.0f;
			}
			
		}
		
		public static Cooldown burstFire(int _burst_count, float _burstCD, float _regularCD)
		{
			BurstImplementation mu = new BurstImplementation (_burst_count, _burstCD, _regularCD);
			return new Cooldown(mu.Cooldown);
		}
		
		private class BurstImplementation{
			private int fired = 0;
			private int burst_count;
			private float burstCD;
			private float regularCD;
			public BurstImplementation(int _burst_count, float _burstCD, float _regularCD)
			{
				burst_count =_burst_count;
				burstCD = _burstCD;
				regularCD = _regularCD;
			}
			
			public float Cooldown(float lastFired)
			{
				if (fired < burst_count) {
					if((Time.time - burstCD) > lastFired)
					{
						++fired;
						return 1.0f;
					}		
					return 0.0f;
				} else {
					if((Time.time - regularCD) > lastFired)
					{
						fired = 0;
						return 1.0f;
					}
					return 0.0f;
				}
			}
		}
		
		//TODO Add actuation function for input smoothing, and charge styles.
		private class canonInstance : ComposedWeapon
		{
			private float _lastFired;
			private UnityEngine.GameObject weaponShot; //TODO refactor to lambdas
			private Cooldown cooldown;
			private FirePattern firePattern;
			private Actuation triggerHandling;
			public canonInstance (Cooldown _cooldown,
			                      FirePattern _firePattern,
			                      Actuation actuator,
			                      GameObject shot)
			{
				triggerHandling = actuator;
				_lastFired = UnityEngine.Time.time;
				cooldown = _cooldown;
				firePattern = _firePattern;
				weaponShot = shot;
			}
			
			public float lastFired
			{
				get
				{
					return _lastFired;
				}
			}
			
			public void shootFrom(UnityEngine.Transform firePoint)
			{
				if (triggerHandling(cooldown, _lastFired) >= 1.0f) {
					_lastFired = UnityEngine.Time.time;
					firePattern(firePoint, weaponShot);
				}
			}
			
		}
		
		public static ComposedWeapon composeWeapon(Cooldown cooldown,
		                                           FirePattern firePattern,
		                                           Actuation triggerHandler,
		                                           GameObject shot)
		{
			return new canonInstance(cooldown, firePattern, triggerHandler, shot);
		}
		
		
	}
	
}